import{sqlite3Worker1Promiser as e}from"@sqlite.org/sqlite-wasm";function n(){return n=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},n.apply(this,arguments)}console.log({sqlite3Worker1Promiser:e});const a="STRFTIME('%Y-%m-%dT%H:%M:%f','NOW')";class t{constructor(e){this._db=void 0,this._dbName=void 0,this._synqDbId=void 0,this._synqPrefix=void 0,this._synqTables=void 0,this._synqBatchSize=20,this.utils={strtimeAsISO8601:a,nowAsISO8601:a,utcNowAsISO8601:()=>new Date((new Date).toUTCString()).toISOString()},this._dbName=e.filename||"",this._db=e.sqlite3||void 0,this._synqPrefix=e.prefix,this._synqTables=e.tables,this._synqBatchSize=e.batchSize||this._synqBatchSize}async init(){var n=this;return this.db?Promise.resolve(this.db):this.dbName?new Promise(async function(a,t){try{console.debug("get promiser...");const s=await new Promise(n=>{console.log("@WTF?");try{const a=e({onready:()=>{console.log("ready?"),n(a)},onerror:e=>{console.error("@ERROR",e)},debug:(...e)=>{console.debug(...e)}});console.log({_promiser:a})}catch(e){console.log("@tryerr"),console.error(e)}});let o;console.debug("get config..."),await s("config-get",{});try{console.debug(`open ${n.dbName}...`),o=await s("open",{filename:`file:${n.dbName}?vfs=opfs`}),console.log("OPFS is available, created persisted database at",o.result.filename.replace(/^file:(.*?)\?vfs=opfs$/,"$1"))}catch(e){o=await s("open",{filename:`file:${n.dbName}`}),console.log("OPFS not available, created in-memory database at",o.result.filename,"$1")}if(!o)return t("Unable to start DB");const{dbId:r}=o;n._synqDbId=r;const i=await s("config-get",{});console.log("Running SQLite3 version",i.result.version.libVersion),n._db=s,a(n)}catch(e){e instanceof Error||(e=new Error(e.result.message)),console.error(e.name,e.message),console.error(e),t("DB setup failed.")}console.groupEnd()}):Promise.reject("No DB filename or connection provided")}get db(){return this._db}get dbName(){return this._dbName}get synqDbId(){return this._synqDbId}get synqPrefix(){return this._synqPrefix}get synqTables(){return this._synqTables}get synqBatchSize(){return this._synqBatchSize}async runQuery({sql:e,values:n}){const a=this.synqDbId;return new Promise((t,s)=>{const o=[];try{this.db("exec",{dbId:a,sql:e,bind:n,callback:e=>{if(!e.row)return t(o);const n={};e.row.forEach((a,t)=>n[e.columnNames[t]]=e.row[t]),o.push(n)}})}catch(e){console.error(e),s(e)}})}async getLastSync(){return this.db.exec(`\n      SELECT * FROM ${this.db.synqPrefix}_meta\n      WHERE meta_name = 'last_local_sync'`).get()}async getChangesSinceLastSync(e,n){let a=n||(await this.getLastSync()).last_local_sync;console.debug("@getChangesSinceLastSync",a);let t="";a&&(t="WHERE modified_at > ?");const s=`\n    SELECT * FROM ${e.synqPrefix}_changes\n      ${t}\n      ORDER BY modified_at ASC\n    `,o=a?[a]:[];return console.debug(s,o),this.runQuery({sql:s,values:o})}async beginTransaction(){const e=`SP${Date.now()}`,n=`SAVEPOINT ${e};`;return await this.runQuery({sql:n}),e}async commitTransaction({savepoint:e}){return this.runQuery({sql:`RELEASE SAVEPOINT ${e};`})}async rollbackTransaction({savepoint:e}){return this.runQuery({sql:`ROLLBACK TRANSACTION TO SAVEPOINT ${e};`})}async applyChange({change:e,savepoint:a}){try{var t;const a=null==(t=this.synqTables)?void 0:t.find(n=>n.name===e.table_name);let s;if(e.data)try{s=JSON.parse(e.data)}catch(n){throw console.debug(e),new Error("Invalid data for insert or update")}if(!a)throw new Error(`Unable to find table ${e.table_name}`);switch(e.operation){case"UPDATE":const t=Object.keys(s).map(e=>`${e} = :${e}`).join(", "),o=n({},s,{[a.id]:e.row_id}),r=`UPDATE ${e.table_name} SET ${t} WHERE ${a.id} = :${a.id}`;await this.runQuery({sql:r,values:o});break;case"INSERT":const i=Object.keys(s).join(","),l=Object.keys(s).map(e=>`:${e}`).join(","),c=`INSERT OR REPLACE INTO ${e.table_name} (${i}) VALUES (${l});`;await this.runQuery({sql:c,values:s});break;case"DELETE":const E=`DELETE FROM ${e.table_name} WHERE ${a.id} = ?`;await this.runQuery({sql:E,values:[e.row_id]})}this.runQuery({sql:`INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value) VALUES('last_local_sync', STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))`})}catch(e){throw await this.rollbackTransaction({savepoint:a}),console.error(`Error applying change: ${e}`),e}}async applyChangesToLocalDB(e){for(let n=0;n<e.length;n+=this.synqBatchSize){const a=e.slice(n,n+this.synqBatchSize),t=await this.beginTransaction();try{for(const e of a)await this.applyChange({change:e,savepoint:t});await this.commitTransaction({savepoint:t})}catch(e){await this.rollbackTransaction({savepoint:t}),console.error(`Transaction failed, changes rolled back: ${e}`)}}console.debug(`Applied ${e.length} change(s)`)}}const s=async({filename:e,sqlite3:n,prefix:a="synql",tables:s,batchSize:o=20})=>{var r;const i=new t({filename:e,sqlite3:n,prefix:a,tables:s,batchSize:o});console.log("@SynQLite db",i);try{await i.init()}catch(e){throw console.error(e),e}a=null==(r=a)?void 0:r.trim().replace(/[^a-z0-9]+$/gi,""),console.debug({prefix:a,batchSize:o}),await i.runQuery({sql:`\n    CREATE TABLE IF NOT EXISTS ${a}_changes (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      data BLOB,\n      operation TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'\n      modified_at TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))\n    );`}),i.runQuery({sql:`CREATE INDEX IF NOT EXISTS ${a}_change_modified_idx ON ${a}_changes(modified_at)`}),i.runQuery({sql:`\n    CREATE TABLE IF NOT EXISTS ${a}_meta (\n      meta_name TEXT NOT NULL PRIMARY KEY,\n      meta_value TEXT NOT NULL\n    );`}),i.runQuery({sql:`CREATE INDEX IF NOT EXISTS ${a}_meta_name_idx ON ${a}_meta(meta_name)`});for(const e of s){console.debug("Setting up",e.name,e.id);const n=await i.runQuery({sql:`\n      SELECT 'json_object(' || GROUP_CONCAT('''' || name || ''', NEW.' || name, ',') || ')' AS jo\n      FROM pragma_table_info('${e.name}');`});console.log(n,n.jo);const t=`\n      CREATE TRIGGER IF NOT EXISTS ${a}_after_insert_${e.name}\n      AFTER INSERT ON ${e.name}\n      FOR EACH ROW\n      BEGIN\n        INSERT INTO ${a}_changes (table_name, row_id, operation, data)\n        VALUES ('${e.name}', NEW.${e.id}, 'INSERT', ${n.jo});\n      END;`;console.log(t),i.runQuery({sql:t}),i.runQuery({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${a}_after_update_${e.name}\n      AFTER UPDATE ON ${e.name}\n      FOR EACH ROW\n      BEGIN\n        INSERT INTO ${a}_changes (table_name, row_id, operation, data)\n        VALUES ('${e.name}', NEW.${e.id}, 'UPDATE', ${n.jo});\n      END;`}),i.runQuery({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${a}_after_delete_${e.name}\n      AFTER DELETE ON ${e.name}\n      FOR EACH ROW\n      BEGIN\n        INSERT INTO ${a}_changes (table_name, row_id, operation) VALUES ('${e.name}', OLD.${e.id}, 'DELETE');\n      END;`})}return i};export{s as default};
//# sourceMappingURL=synqlite.modern.js.map
